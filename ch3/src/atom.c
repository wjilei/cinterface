#include <string.h>
#include <limits.h>
#include "assert.h"
#include "atom.h"
#include "mem.h"


#define NELEMS(arr) \
	(sizeof(arr)/sizeof(arr[0]))


static struct atom {
	struct atom * link;
	int len;
	char *str;
} *buckets[2048];

static unsigned long scatter[256] = {
	100627655,1982182287,2115861879,932282638,174045179,971146878,
	191455005,1248710469,1561756536,2017821525,2140494847,1359504973,
	932141524,948671254,950913,868123508,1425968419,2144782104,
	2028283310,197248683,199295743,1732392018,814701543,640275010,
	2042475007,1051741639,531539829,1434468271,1073084540,582610329,
	1031662732,1173712195,417308969,1000040963,2105994833,591354148,
	1971187841,149966191,1840064617,1385460729,20304068,1833075816,
	597482054,952445593,634263422,598432968,1820569101,2060231841,
	595731424,1701368764,109996876,795027167,1286277134,924698419,
	1435302178,1181268493,1976440059,1966842007,468253116,902040951,
	401968688,1499915848,2075753146,819277657,352473163,2034264331,
	1410631805,176177357,36746874,1103212774,1561638086,57050943,
	788804943,11636493,1009496536,1423068365,610069461,682581989,
	1335816559,1205800885,236467105,1445813435,2000828053,1522744239,
	223028207,1288646583,556529084,51984618,1108004942,1024782201,
	954025569,1509973630,377214401,882295067,181767640,729687565,
	769075750,1592399445,905864922,805822625,548128572,320019360,
	862873568,1336933515,331655853,1872370104,612518232,941725314,
	407468445,1948334791,42552,643935551,1246664579,2000870605,
	19196142,1469692786,1142033540,575725227,1521677404,102554834,
	1600507428,328219325,1612528464,1977721829,1210514392,1794296104,
	559925746,1979590142,1239211902,1465790668,637929119,1787340474,
	1785810029,1500802687,976790341,2117465882,1225689143,1589308573,
	911707549,1633157589,1390159717,911750101,129609492,489340648,
	765137058,148805634,1959033434,1907170598,724530861,1333227190,
	2009725432,177554641,1661446515,1474770248,7792823,724477259,
	1121582705,567718569,556583753,213310959,2033509238,1194512873,
	2000651433,1671835619,547831912,829958126,1641817853,1773521056,
	271783051,406041754,1259194997,1661942768,1317791855,1388804489,
	3799768,2082928913,1537610123,1962833202,1842615863,114657337,
	1148576744,1704857647,292211978,662539611,1032144248,300004801,
	1387016870,6243305,867723371,1943600624,219554264,753748961,
	990629849,72722049,278100932,1538461761,902680175,1919918785,
	1164499169,1174463226,178476892,276210518,688922347,1496268747,
	1665015007,692722115,1431714013,1055141483,508071670,1126846228,
	1169798820,1656648414,684220228,1462010798,171704378,1716364476,
	1762015600,1558721248,1722607781,482255323,1354838224,1942162045,
	1236004284,197984425,2014884094,1514105216,1736446187,770080621,
	1286540353,753461708,1944543847,1465017245,1029672227,485982546,
	813802345,547203586,1178704662,98032710,1602345069,1686776332,
	1224878938,624660241,1195941098,1909099166,2086671040,1367645476,
	1477979994,1701202992,778883077,1053104127,35974667,2133721301,
	847782524,1271978951,184222079,715182970
};

const char *Atom_string(const char *str) {
	assert(str);
	return Atom_new(str, strlen(str));
}


const char *Atom_int(long n) {
	char str[43];
	// 指针指向数组的最后一个元素后面
	char *s = str + sizeof(str);
	unsigned long m;

	if (n == LONG_MIN) {
		m = LONG_MAX + 1UL;
	} else if (n < 0) {
		m = -n;
	} else {
		m = n;
	}

	// 把数字倒序存入字符数组中
	do {
		*--s = m%10 + '0';
	} while((m / 10) > 0);

	if(n < 0) {
		*--s = '-';
	}

	return Atom_new(s, (str + sizeof(str) - s));
}

static unsigned long hash(const char *str, int len) {
	unsigned long h;
	int i;

	assert(str);
	assert(len >= 0);

	// h = hash(str)
	for (h=0, i=0; i<len; i++) {
		h = (h<<1) + scatter[(unsigned char)str[i]];
	}
	return h;
}


const char *Atom_new(const char *str, int len) {
	unsigned long h;
	int i;
	struct atom *p;

	assert(str);
	assert(len >= 0);

	// 计算hash值 h
	h = hash(str, len);
	// h &= NELEMS(buckets)-1;
	h %= NELEMS(buckets);

	for (p = buckets[h]; p; p = p->link) {
		if (len == p->len) {
			for (i = 0;i < len && p->str[i] == str[i];i ++)
				;
			if (i == len) {
				return p->str;
			}
		}
	}

	// allocate a new entry
	p = ALLOC(sizeof(*p) + len + 1);
	p->len = len;
	p->str = (char*)(p+1);
	if (len > 0) {
		memcpy(p->str, str, len);
	}
	p->str[len] = '\0';
	p->link = buckets[h];
	buckets[h] = p;

	return p->str;
}

int Atom_length(const char *str) {
	struct atom *p;
	int i;

	assert(str);
	for (i=0; i<NELEMS(buckets); i++) {
		for (p=buckets[i];p;p=p->link) {
			if (p->str == str) {
				return p->len;
			}
		}
	}

	assert(0);
	return 0;
}

void Atom_free(char *str) {
	unsigned long h;
	int len;
	int i;
	struct atom *p,*pprev;
	assert(str);

	len = strlen(str);
	h = hash(str, len);
	h %= NELEMS(buckets);

	for (p = buckets[h]; p; pprev = p, p = p->link) {
		if (len == p->len) {
			for (i = 0;i < len && p->str[i] == str[i];i ++)
				;
			if (i == len) {
				pprev->link = p->link;
				p->link = NULL;
				FREE(p);
				return;
			}
		}
	}

	return;
}